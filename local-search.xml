<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于HashMap初始化容量问题</title>
    <link href="/2020/04/29/%E5%85%B3%E4%BA%8EHashMap%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/29/%E5%85%B3%E4%BA%8EHashMap%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>基于阿里代码规范HashMap 需要初始化大小问题了解了一波</p><h2 id="关于jdk内描述"><a href="#关于jdk内描述" class="headerlink" title="关于jdk内描述"></a>关于jdk内描述</h2><p>HashMap的实例有两个参数影响其性能：初始容量和加载因子。</p><p>首先我们来看初始容量和加载因子的定义。</p><p>容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。</p><p>加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。</p><p>当哈希表中条目的数目超过 容量乘加载因子 的时候，则要对该哈希表进行rehash操作，从而哈希表将具有大约两倍的桶数。</p><p>当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。从hashmap中get元素时，首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。如果每个位置上的链表只有一个元素，那么hashmap的get效率将是最高的。</p><h2 id="HashMap为元素选择下标的方法"><a href="#HashMap为元素选择下标的方法" class="headerlink" title="HashMap为元素选择下标的方法"></a>HashMap为元素选择下标的方法</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;         <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);     &#125; </code></pre><p>当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p><p>所以，在存储大容量数据的时候，最好预先指定hashmap的size为2的整数次幂次方。就算不指定的话，也会以大于且最接近指定值大小的2次幂来初始化的，代码如下(HashMap的构造方法中)：</p><pre><code class="hljs java"><span class="hljs-comment">// Find a power of 2 &gt;= initialCapacity  </span>        <span class="hljs-keyword">int</span> capacity = <span class="hljs-number">1</span>;          <span class="hljs-keyword">while</span> (capacity &lt; initialCapacity)               capacity &lt;&lt;= <span class="hljs-number">1</span>;  </code></pre><h2 id="关于HashMap的rehash"><a href="#关于HashMap的rehash" class="headerlink" title="关于HashMap的rehash"></a>关于HashMap的rehash</h2><p>当元素个数超过数组长度*加载因子时，HashMap将发生扩容，使其提高查询效率，但当其扩容后，原数组中的数据必须重新计算其在新数组中的位置，并放进去，这是一个导致消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有100个元素,100/0.75 = 133.33。为了防止rehash，向上取整，为134  但是new HashMap(134)显然不符合数组长度为2的n次幂的时候效率更高，  我们必须这样new HashMap(256)才最合适，既考虑了&amp;的问题，也避免了rehash的问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web前端获取粘贴板图片</title>
    <link href="/2020/04/26/web%E7%AB%AF%E8%8E%B7%E5%8F%96%E7%B2%98%E8%B4%B4%E6%9D%BF%E5%9B%BE%E7%89%87/"/>
    <url>/2020/04/26/web%E7%AB%AF%E8%8E%B7%E5%8F%96%E7%B2%98%E8%B4%B4%E6%9D%BF%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h2 id="web前端js"><a href="#web前端js" class="headerlink" title="web前端js"></a>web前端js</h2><pre><code class="hljs javaScript">bindPaste();<span class="hljs-comment">//绑定粘贴事件</span><span class="hljs-keyword">var</span> base64_str = <span class="hljs-literal">null</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindPaste</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//定义变量存储获取的图片内容</span><span class="hljs-keyword">var</span> blob;<span class="hljs-comment">//获取body对象</span><span class="hljs-keyword">var</span> body = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"body"</span>);<span class="hljs-comment">//定义body标签绑定的粘贴事件处理函数</span><span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<span class="hljs-comment">//获取clipboardData对象</span><span class="hljs-keyword">var</span> data = e.clipboardData || <span class="hljs-built_in">window</span>.clipboardData;<span class="hljs-comment">//获取图片内容</span>blob = data.items[<span class="hljs-number">0</span>].getAsFile();<span class="hljs-comment">//判断是不是图片，最好通过文件类型判断</span><span class="hljs-keyword">var</span> isImg = (blob &amp;&amp; <span class="hljs-number">1</span>) || <span class="hljs-number">-1</span>;<span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> FileReader();<span class="hljs-comment">//文件读取完成时触发</span>reader.onload = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"获得粘贴的结果"</span>, e.target.result);base64_str = e.target.result;<span class="hljs-comment">//div中的img标签src属性赋值，可以直接展示图片</span>$(<span class="hljs-string">"#screenShoot"</span>).attr(<span class="hljs-string">"src"</span>, base64_str);<span class="hljs-comment">//显示div</span>$(<span class="hljs-string">"#screenShoot"</span>).css(<span class="hljs-string">"display"</span>, <span class="hljs-string">"block"</span>);&#125;&#125;)();<span class="hljs-keyword">if</span> (isImg &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//将文件读取为 DataURL</span>reader.readAsDataURL(blob);&#125;&#125;<span class="hljs-comment">//通过body标签绑定粘贴事件，注意有些标签绑定粘贴事件可能出错</span>body[<span class="hljs-number">0</span>].removeEventListener(<span class="hljs-string">'paste'</span>, fun);body[<span class="hljs-number">0</span>].addEventListener(<span class="hljs-string">'paste'</span>, fun);&#125;$(<span class="hljs-string">"#sendBtn"</span>).on(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;$.ajax(&#123;type: <span class="hljs-string">'get'</span>,url: conf.global_url + <span class="hljs-string">"/device/saveToImgByStr"</span>,data: &#123;base64Str: base64_str,&#125;,cache: <span class="hljs-literal">false</span>,<span class="hljs-keyword">async</span>: <span class="hljs-literal">false</span>,dataType: <span class="hljs-string">'json'</span>,contentType: <span class="hljs-string">'application/x-www-form-urlencoded;charset=UTF-8'</span>,success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"result"</span> + result);&#125;,error: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">XMLHttpRequest, textStatus, errorThrown</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'系统异常！'</span>);&#125;&#125;)&#125;)</code></pre><h2 id="后台获取base64数据转换图片并保存"><a href="#后台获取base64数据转换图片并保存" class="headerlink" title="后台获取base64数据转换图片并保存"></a>后台获取base64数据转换图片并保存</h2><pre><code class="hljs java"><span class="hljs-comment">//springboot 跨域注解</span>    <span class="hljs-meta">@CrossOrigin</span>(origins = <span class="hljs-string">"*"</span>)    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/saveToImgByStr"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">saveToImgByStr</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, String base64Str)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        String destDir = <span class="hljs-string">"/upload/image"</span>;        <span class="hljs-comment">//非springboot项目 可设置请求头解决跨域问题</span><span class="hljs-comment">//        response.setHeader("Access-Control-Allow-Origin", "*");</span>        base64Str = base64Str.replaceAll(<span class="hljs-string">"data:image/png;base64,"</span>, <span class="hljs-string">""</span>);        BASE64Decoder decoder = <span class="hljs-keyword">new</span> BASE64Decoder();        <span class="hljs-keyword">byte</span>[] imageByte = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            imageByte = decoder.decodeBuffer(base64Str);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; imageByte.length; ++i) &#123;                <span class="hljs-keyword">if</span> (imageByte[i] &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 调整异常数据</span>                    imageByte[i] += <span class="hljs-number">256</span>;                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">if</span> (imageByte.length &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//获取文件上传的真实路径</span><span class="hljs-comment">//                String uploadPath = request.getSession().getServletContext().getRealPath("/");</span>                <span class="hljs-comment">//保存文件的路径</span>                String filepath = destDir + File.separator + createNewDir();                File destfile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:"</span> + filepath);                <span class="hljs-keyword">if</span> (!destfile.exists()) &#123;                    destfile.mkdirs();                &#125;                <span class="hljs-comment">//文件新名称</span>                String fileNameNew = getFileNameNew() + <span class="hljs-string">".png"</span>;                File f = <span class="hljs-keyword">new</span> File(destfile.getAbsoluteFile() + File.separator + fileNameNew);                <span class="hljs-comment">// 将字符串转换成二进制，用于显示图片</span>                <span class="hljs-comment">// 将上面生成的图片格式字符串 imgStr，还原成图片显示</span>                InputStream in = <span class="hljs-keyword">new</span> ByteArrayInputStream(imageByte);                FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(f);                <span class="hljs-comment">// BufferedOutputStream bos = new BufferedOutputStream(fos);</span>                <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];                <span class="hljs-keyword">int</span> length;                length = in.read(buf, <span class="hljs-number">0</span>, buf.length);                <span class="hljs-keyword">while</span> (length != -<span class="hljs-number">1</span>) &#123;                    fos.write(buf, <span class="hljs-number">0</span>, length);                    length = in.read(buf);                &#125;                fos.flush();                fos.close();                in.close();                String lastpath = filepath + File.separator + fileNameNew;                LOGGER.info(<span class="hljs-string">"返回图片路径："</span> + lastpath);;                <span class="hljs-keyword">return</span> lastpath;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;</code></pre>        ]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>日语测试</title>
    <link href="/2020/04/23/%E6%97%A5%E8%AF%AD%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/04/23/%E6%97%A5%E8%AF%AD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>梦(ゆめ)ならばどれほどよかったでしょう</p><p>未(いま)だにあなたのことを梦(ゆめ)にみる</p><p>忘(わす)れた物(もの)を取(と)りに帰(かえ)るように</p><p>古(ふる)びた思(おも)い出(で)の埃(ほこり)を払(はら)う</p><p>戻(もど)らない幸(しあわ)せがあることを</p><p>最後(さいご)にあなたが教(おし)えてくれた</p><p>言(い)えずに隠(かく)してた昏(くら)い过去(かこ)も</p><p>あなたがいなきゃ永远(えいえん)に昏(くら)いまま</p><p>きっともうこれ以上(いじょう) 伤(きず)つくことなど</p><p>ありはしないとわかっている</p><p>あの日(ひ)の悲(かな)しみさえ</p><p>あの日(ひ)の苦(くる)しみさえ</p><p>そのすべてを爱(あい)してた あなたとともに</p><p>胸(むね)に残(のこ)り离(はな)れない</p><p>苦(にが)いレモン(れもん)の匂(にお)い</p><p>雨(あめ)が降(ふ)り止(や)むまでは帰(かえ)れない</p><p>今(いま)でもあなたはわたしの光(ひかり)</p><p>暗闇(くらやみ)であなたの背(せ)をなぞった</p><p>その轮廓(りんかく)を鲜明(せんめい)に覚(おぼ)えている</p><p>受(う)け止(と)めきれないものと出会(であ)うたび</p><p>溢(あふ)れてやまないのは涙(なみだ)だけ</p><p>何(なに)をしていたの</p><p>何(なに)を见(み)ていたの</p><p>わたしの知(し)らない横颜(よこがお)で</p><p>どこかであなたが今(いま)</p><p>わたしと同(おな)じ様(よう)な</p><p>涙(なみだ)にくれ 淋(さび)しさの中(なか)にいるなら</p><p>わたしのことなどどうか 忘(わす)れてください</p><p>そんなことを心(こころ)から愿(ねが)うほどに</p><p>今(いま)でもあなたはわたしの光(ひかり)</p><p>自分(じぶん)が思(おも)うより 恋(こい)をしていたあなたに</p><p>あれから思(おも)うように 息(いき)ができない</p><p>あんなに侧(そば)にいたのにまるで嘘(うそ)みたい</p><p>とても忘(わす)れられないそれだけが确(たし)か</p><p>あの日(ひ)の悲(かな)しみさえ<br>　　あの日(ひ)の苦(くる)しみさえ</p><p>その全(すべ)てを爱(あい)してたあなたと共(とも)に</p><p>胸(むね)に残(のこ)り离(はな)れない</p><p>苦(にが)いレモン(れもん)の匂(にお)い</p><p>雨(あめ)が降(ふ)り止(や)むまでは帰(かえ)れない</p><p>切(き)り分(わ)けた果実(かじつ)の片方(かたほう)の様(よう)に</p><p>今(いま)でもあなたはわたしの光(ひかり)。</p>]]></content>
    
    
    
    <tags>
      
      <tag>lemon歌词</tag>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中文测试</title>
    <link href="/2020/04/23/%E4%B8%AD%E6%96%87%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/04/23/%E4%B8%AD%E6%96%87%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>中文测试 Chinese test 王老板51来玩啊 。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
