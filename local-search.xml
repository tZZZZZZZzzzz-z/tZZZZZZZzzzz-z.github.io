<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于视频通话截图</title>
    <link href="/2020/05/06/%E5%85%B3%E4%BA%8E%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D%E6%88%AA%E5%9B%BE/"/>
    <url>/2020/05/06/%E5%85%B3%E4%BA%8E%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D%E6%88%AA%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>最近有个需求需要截取视频通话的客户界面传给后台做业务处理，百度了一下最多的都是html2canvas。</p><p>html2canvas  其实是遍历dom元素 将html内容渲染成canvas图片。</p><p>当我选取video标签时发现 渲染出来的只有一张白色的图片，才知道视频并不能直接渲染成图片。百度一番，发现解决方案都是将视频当前帧渲染成canvas图片，直接上代码吧。</p><figure class="highlight javascript"><figcaption><span>[] [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"><span class="hljs-comment">//将视频通话当前帧画入canvas画布</span><br><span class="hljs-keyword">let</span> video = $(<span class="hljs-string">"#remote_stream"</span>).find(<span class="hljs-string">"video"</span>)[<span class="hljs-number">0</span>];<br>video.style.backgroundImage = <span class="hljs-string">""</span>;<br><span class="hljs-keyword">if</span> (video.style.backgroundImage == <span class="hljs-string">""</span>) &#123;<br><span class="hljs-keyword">let</span> width = $(video).width();<br><span class="hljs-keyword">let</span> height = $(video).height();<br>$(video).after(<span class="hljs-string">'&lt;canvas width="'</span> + width + <span class="hljs-string">'" height="'</span> + height + <span class="hljs-string">'"&gt;&lt;/canvas&gt;'</span>);<br><span class="hljs-keyword">let</span> canvas = $(video).next(<span class="hljs-string">'canvas'</span>).css(&#123;<br>display: <span class="hljs-string">'none'</span><br>&#125;);<br><span class="hljs-keyword">let</span> ctx = canvas.get(<span class="hljs-number">0</span>).getContext(<span class="hljs-string">'2d'</span>);<br>ctx.drawImage(video, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br><span class="hljs-keyword">try</span> &#123;<br>video.style.backgroundImage = <span class="hljs-string">"url("</span> + canvas.get(<span class="hljs-number">0</span>).toDataURL(<span class="hljs-string">'image/png'</span>) + <span class="hljs-string">")"</span>;<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br><span class="hljs-built_in">console</span>.log(e)<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>canvas.remove();<br>&#125;<br>&#125;<br><span class="hljs-comment">//html2canvas根据video标签渲染截图</span><br>html2canvas($(<span class="hljs-string">"#remote_stream"</span>).find(<span class="hljs-string">"video"</span>)[<span class="hljs-number">0</span>]).then(<span class="hljs-function"><span class="hljs-params">canvas</span> =&gt;</span> &#123;<br>base64Str = canvas.toDataURL(<span class="hljs-string">'image/jpeg'</span>, <span class="hljs-number">1.0</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>html2canvas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于HashMap初始化容量问题</title>
    <link href="/2020/04/29/%E5%85%B3%E4%BA%8EHashMap%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/29/%E5%85%B3%E4%BA%8EHashMap%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>基于阿里代码规范HashMap 需要初始化大小问题了解了一波</p><h2 id="关于jdk内描述"><a href="#关于jdk内描述" class="headerlink" title="关于jdk内描述"></a>关于jdk内描述</h2><p>HashMap的实例有两个参数影响其性能：初始容量和加载因子。</p><p>首先我们来看初始容量和加载因子的定义。</p><p>容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。</p><p>加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。</p><p>当哈希表中条目的数目超过 容量乘加载因子 的时候，则要对该哈希表进行rehash操作，从而哈希表将具有大约两倍的桶数。</p><p>当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。从hashmap中get元素时，首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。如果每个位置上的链表只有一个元素，那么hashmap的get效率将是最高的。</p><h2 id="HashMap为元素选择下标的方法"><a href="#HashMap为元素选择下标的方法" class="headerlink" title="HashMap为元素选择下标的方法"></a>HashMap为元素选择下标的方法</h2><figure class="highlight java"><figcaption><span>[length为数组长度,h为key获取到的hashcode] [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;  <br>       <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);  <br>   &#125; <br></code></pre></td></tr></table></figure><p>当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p><p>所以，在存储大容量数据的时候，最好预先指定hashmap的size为2的整数次幂次方。就算不指定的话，也会以大于且最接近指定值大小的2次幂来初始化的，代码如下(HashMap的构造方法中)：</p><figure class="highlight java"><figcaption><span>[] [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Find a power of 2 &gt;= initialCapacity  </span><br>        <span class="hljs-keyword">int</span> capacity = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">while</span> (capacity &lt; initialCapacity)   <br>            capacity &lt;&lt;= <span class="hljs-number">1</span>;  <br></code></pre></td></tr></table></figure><h2 id="关于HashMap的rehash"><a href="#关于HashMap的rehash" class="headerlink" title="关于HashMap的rehash"></a>关于HashMap的rehash</h2><p>当元素个数超过数组长度*加载因子时，HashMap将发生扩容，使其提高查询效率，但当其扩容后，原数组中的数据必须重新计算其在新数组中的位置，并放进去，这是一个导致消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有100个元素,100/0.75 = 133.33。为了防止rehash，向上取整，为134  但是new HashMap(134)显然不符合数组长度为2的n次幂的时候效率更高，  我们必须这样new HashMap(256)才最合适，既考虑了&amp;的问题，也避免了rehash的问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>hashmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web前端获取粘贴板图片</title>
    <link href="/2020/04/26/web%E7%AB%AF%E8%8E%B7%E5%8F%96%E7%B2%98%E8%B4%B4%E6%9D%BF%E5%9B%BE%E7%89%87/"/>
    <url>/2020/04/26/web%E7%AB%AF%E8%8E%B7%E5%8F%96%E7%B2%98%E8%B4%B4%E6%9D%BF%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h2 id="web前端js"><a href="#web前端js" class="headerlink" title=" web前端js"></a> web前端js</h2><figure class="highlight javascript"><figcaption><span>前端获取粘贴板图片点击按钮提交base64数据到后台 [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javaScript">bindPaste();<br><span class="hljs-comment">//绑定粘贴事件</span><br><span class="hljs-keyword">var</span> base64_str = <span class="hljs-literal">null</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindPaste</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-comment">//定义变量存储获取的图片内容</span><br><span class="hljs-keyword">var</span> blob;<br><span class="hljs-comment">//获取body对象</span><br><span class="hljs-keyword">var</span> body = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"body"</span>);<br><span class="hljs-comment">//定义body标签绑定的粘贴事件处理函数</span><br><span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br><span class="hljs-comment">//获取clipboardData对象</span><br><span class="hljs-keyword">var</span> data = e.clipboardData || <span class="hljs-built_in">window</span>.clipboardData;<br><span class="hljs-comment">//获取图片内容</span><br>blob = data.items[<span class="hljs-number">0</span>].getAsFile();<br><span class="hljs-comment">//判断是不是图片，最好通过文件类型判断</span><br><span class="hljs-keyword">var</span> isImg = (blob &amp;&amp; <span class="hljs-number">1</span>) || <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> FileReader();<br><span class="hljs-comment">//文件读取完成时触发</span><br>reader.onload = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"获得粘贴的结果"</span>, e.target.result);<br>base64_str = e.target.result;<br><span class="hljs-comment">//div中的img标签src属性赋值，可以直接展示图片</span><br>$(<span class="hljs-string">"#screenShoot"</span>).attr(<span class="hljs-string">"src"</span>, base64_str);<br><span class="hljs-comment">//显示div</span><br>$(<span class="hljs-string">"#screenShoot"</span>).css(<span class="hljs-string">"display"</span>, <span class="hljs-string">"block"</span>);<br>&#125;<br>&#125;)();<br><span class="hljs-keyword">if</span> (isImg &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//将文件读取为 DataURL</span><br>reader.readAsDataURL(blob);<br>&#125;<br>&#125;<br><span class="hljs-comment">//通过body标签绑定粘贴事件，注意有些标签绑定粘贴事件可能出错</span><br>body[<span class="hljs-number">0</span>].removeEventListener(<span class="hljs-string">'paste'</span>, fun);<br>body[<span class="hljs-number">0</span>].addEventListener(<span class="hljs-string">'paste'</span>, fun);<br>&#125;<br>$(<span class="hljs-string">"#sendBtn"</span>).on(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>$.ajax(&#123;<br>type: <span class="hljs-string">'get'</span>,<br>url: conf.global_url + <span class="hljs-string">"/device/saveToImgByStr"</span>,<br>data: &#123;<br>base64Str: base64_str,<br>&#125;,<br>cache: <span class="hljs-literal">false</span>,<br><span class="hljs-keyword">async</span>: <span class="hljs-literal">false</span>,<br>dataType: <span class="hljs-string">'json'</span>,<br>contentType: <span class="hljs-string">'application/x-www-form-urlencoded;charset=UTF-8'</span>,<br>success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"result"</span> + result);<br>&#125;,<br>error: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">XMLHttpRequest, textStatus, errorThrown</span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'系统异常！'</span>);<br>&#125;<br>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="后台获取base64数据转换图片并保存"><a href="#后台获取base64数据转换图片并保存" class="headerlink" title=" 后台获取base64数据转换图片并保存"></a> 后台获取base64数据转换图片并保存</h2><figure class="highlight java"><figcaption><span>[title] [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//springboot 跨域注解</span><br>    <span class="hljs-meta">@CrossOrigin</span>(origins = <span class="hljs-string">"*"</span>)<br>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/saveToImgByStr"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">saveToImgByStr</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, String base64Str)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String destDir = <span class="hljs-string">"/upload/image"</span>;<br>        <span class="hljs-comment">//非springboot项目 可设置请求头解决跨域问题</span><br><span class="hljs-comment">//        response.setHeader("Access-Control-Allow-Origin", "*");</span><br>        base64Str = base64Str.replaceAll(<span class="hljs-string">"data:image/png;base64,"</span>, <span class="hljs-string">""</span>);<br>        BASE64Decoder decoder = <span class="hljs-keyword">new</span> BASE64Decoder();<br>        <span class="hljs-keyword">byte</span>[] imageByte = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            imageByte = decoder.decodeBuffer(base64Str);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; imageByte.length; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (imageByte[i] &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 调整异常数据</span><br>                    imageByte[i] += <span class="hljs-number">256</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (imageByte.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//获取文件上传的真实路径</span><br><span class="hljs-comment">//                String uploadPath = request.getSession().getServletContext().getRealPath("/");</span><br>                <span class="hljs-comment">//保存文件的路径</span><br>                String filepath = destDir + File.separator + createNewDir();<br>                File destfile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:"</span> + filepath);<br>                <span class="hljs-keyword">if</span> (!destfile.exists()) &#123;<br>                    destfile.mkdirs();<br>                &#125;<br>                <span class="hljs-comment">//文件新名称</span><br>                String fileNameNew = getFileNameNew() + <span class="hljs-string">".png"</span>;<br>                File f = <span class="hljs-keyword">new</span> File(destfile.getAbsoluteFile() + File.separator + fileNameNew);<br>                <span class="hljs-comment">// 将字符串转换成二进制，用于显示图片</span><br>                <span class="hljs-comment">// 将上面生成的图片格式字符串 imgStr，还原成图片显示</span><br>                InputStream in = <span class="hljs-keyword">new</span> ByteArrayInputStream(imageByte);<br>                FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(f);<br>                <span class="hljs-comment">// BufferedOutputStream bos = new BufferedOutputStream(fos);</span><br>                <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                <span class="hljs-keyword">int</span> length;<br>                length = in.read(buf, <span class="hljs-number">0</span>, buf.length);<br><br>                <span class="hljs-keyword">while</span> (length != -<span class="hljs-number">1</span>) &#123;<br>                    fos.write(buf, <span class="hljs-number">0</span>, length);<br>                    length = in.read(buf);<br>                &#125;<br>                fos.flush();<br>                fos.close();<br>                in.close();<br>                String lastpath = filepath + File.separator + fileNameNew;<br>                LOGGER.info(<span class="hljs-string">"返回图片路径："</span> + lastpath);;<br>                <span class="hljs-keyword">return</span> lastpath;<br><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>        ]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 8 stream Collectors 操作</title>
    <link href="/2020/04/25/java8stream/"/>
    <url>/2020/04/25/java8stream/</url>
    
    <content type="html"><![CDATA[<h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><p>Collectors 是 Java 8 加入的操作类，位于 java.util.stream 包下。它会根据不同的策略将元素收集归纳起来，比如最简单常用的是将元素装入Map、Set、List 等可变容器中。特别对于 Java 8 Stream Api 来说非常有用。它提供了collect() 方法来对 Stream 流进行终结操作派生出基于各种策略的结果集。</p><figure class="highlight java"><figcaption><span>[] [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; language = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        language.add(<span class="hljs-string">"Java"</span>);<br>        language.add(<span class="hljs-string">"PHP"</span>);<br>        language.add(<span class="hljs-string">"Python"</span>);<br>        language.add(<span class="hljs-string">"Go"</span>);<br>        language.add(<span class="hljs-string">"C#"</span>);<br></code></pre></td></tr></table></figure><h2 id="Java-8-中-Collectors-的方法"><a href="#Java-8-中-Collectors-的方法" class="headerlink" title="Java 8 中 Collectors 的方法"></a>Java 8 中 Collectors 的方法</h2><p>Collectors 提供了一系列的静态方法供我们使用，通常情况我们静态导入即可使用。</p><figure class="highlight java"><figcaption><span>[] [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Collectors.toList();<br>  Collectors.toMap();<br>  Collectors.toSet();<br>  Collectors.toCollection();<br>  Collectors.toConcurrentMap();<br></code></pre></td></tr></table></figure><h2 id="joining"><a href="#joining" class="headerlink" title="joining"></a>joining</h2><p>将元素以某种规则连接起来。该方法有两种种重载 joining(CharSequence delimiter) 和 joining(CharSequence delimiter,CharSequence prefix,CharSequence suffix)</p><figure class="highlight java"><figcaption><span>[] [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//   输出 JavaPHPPythonGoC#</span><br> language.stream().collect(Collectors.joining());<br><br> <span class="hljs-comment">//   输出 Java,PHP,Python,Go,C#</span><br> language.stream().collect(Collectors.joining(<span class="hljs-string">","</span> ));<br><br> <span class="hljs-comment">//   输出 [Java,PHP,Python,Go,C#]</span><br> language.stream().collect(Collectors.joining(<span class="hljs-string">","</span>, <span class="hljs-string">"["</span>, <span class="hljs-string">"]"</span>));<br></code></pre></td></tr></table></figure><h2 id="collectingAndThen"><a href="#collectingAndThen" class="headerlink" title="collectingAndThen"></a>collectingAndThen</h2><p>该方法先执行了一个归纳操作，然后再对归纳的结果进行 Function 函数处理输出一个新的结果。</p><figure class="highlight java"><figcaption><span>[] [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//   先进行了joining操作再转为大写 输出为 JAVA,PHP,PYTHON,GO,C#</span><br>language.stream().collect(Collectors.collectingAndThen(Collectors.joining(<span class="hljs-string">","</span>), String::toUpperCase));<br></code></pre></td></tr></table></figure><h2 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h2><p>按照条件对元素进行分组</p><figure class="highlight java"><figcaption><span>[] [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 按照字符串长度进行分组，符合条件的元素将组成一个 List 映射到以条件长度为key 的 Map&lt;Integer, List&lt;String&gt;&gt; 中</span><br> language.stream().collect(Collectors.groupingBy(String::length))<br></code></pre></td></tr></table></figure><h2 id="counting"><a href="#counting" class="headerlink" title="counting"></a>counting</h2><p>归纳元素的的数量</p><figure class="highlight java"><figcaption><span>[] [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输出 5</span><br> language.stream().collect(Collectors.counting())<br></code></pre></td></tr></table></figure><h2 id="maxBy-minBy"><a href="#maxBy-minBy" class="headerlink" title="maxBy/minBy"></a>maxBy/minBy</h2><p>这两个方法分别提供了查找大小元素的操作，它们基于比较器接口 Comparator 来比较 ，返回的是一个 Optional 对象。</p><figure class="highlight java"><figcaption><span>[] [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输出 Go</span><br>Optional&lt;String&gt; min = language.stream().collect(Collectors.minBy(Comparator.comparingInt(String::length)));<br></code></pre></td></tr></table></figure><h2 id="summingInt-Double-Long"><a href="#summingInt-Double-Long" class="headerlink" title="summingInt/Double/Long"></a>summingInt/Double/Long</h2><p>用来做累加计算。计算元素某个属性的总和,类似 Mysql 的 sum 函数</p><figure class="highlight java"><figcaption><span>[] [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 总长度17</span><br> language.stream().collect(Collectors.summingInt(l -&gt; l.length()));<br></code></pre></td></tr></table></figure><h2 id="summarizingInt-Double-Long"><a href="#summarizingInt-Double-Long" class="headerlink" title="summarizingInt/Double/Long"></a>summarizingInt/Double/Long</h2><p>如果我们总数,总和,最大最小值这些都要呢，summarizingInt、summarizingDouble、summarizingLong这三个方法通过对元素某个属性的提取，会返回对元素该属性的统计数据对象，分别对应 IntSummaryStatistics、DoubleSummaryStatistics、LongSummaryStatistics。 </p><figure class="highlight java"><figcaption><span>[] [] [url] [link text] [additional options]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">DoubleSummaryStatistics doubleSummaryStatistics = language.stream().collect(Collectors.summarizingDouble(String::length));<br>  <span class="hljs-comment">// DoubleSummaryStatistics&#123;count=5, sum=17.000000, min=2.000000, average=3.400000, max=6.000000&#125;</span><br>  System.out.println(doubleSummaryStatistics.toString());<br></code></pre></td></tr></table></figure><p>结果 DoubleSummaryStatistics 中包含了 总数，总和，最小值，最大值，平均值 五个值</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>stream</tag>
      
      <tag>Collectors</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
